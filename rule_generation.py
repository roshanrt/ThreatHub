import streamlit as st
import pandas as pd
import json
import re
import io
import base64
from datetime import datetime

def generate_sigma_rule(iocs, rule_name, description):
    """Generate a Sigma rule based on the provided IOCs"""
    sigma_rule = {
        "title": rule_name,
        "id": f"sigma-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        "status": "experimental",
        "description": description,
        "author": st.session_state.username,
        "date": datetime.now().strftime("%Y/%m/%d"),
        "references": [],
        "logsource": {
            "category": "proxy"
        },
        "detection": {
            "selection": {}
        },
        "falsepositives": ["Unknown"],
        "level": "medium"
    }
    
    # Add IOCs to the rule
    if iocs.get("ip_addresses"):
        sigma_rule["detection"]["selection"]["destination.ip"] = iocs["ip_addresses"]
    
    if iocs.get("domains"):
        sigma_rule["detection"]["selection"]["destination.domain"] = iocs["domains"]
    
    if iocs.get("urls"):
        sigma_rule["detection"]["selection"]["url.original"] = iocs["urls"]
    
    # Add condition
    sigma_rule["detection"]["condition"] = "selection"
    
    # Convert to YAML-like format (as a string)
    yaml_str = "title: " + sigma_rule["title"] + "\n"
    yaml_str += "id: " + sigma_rule["id"] + "\n"
    yaml_str += "status: " + sigma_rule["status"] + "\n"
    yaml_str += "description: " + sigma_rule["description"] + "\n"
    yaml_str += "author: " + sigma_rule["author"] + "\n"
    yaml_str += "date: " + sigma_rule["date"] + "\n"
    yaml_str += "logsource:\n"
    yaml_str += "  category: " + sigma_rule["logsource"]["category"] + "\n"
    yaml_str += "detection:\n"
    yaml_str += "  selection:\n"
    
    for key, values in sigma_rule["detection"]["selection"].items():
        yaml_str += f"    {key}:\n"
        for value in values:
            yaml_str += f"      - '{value}'\n"
    
    yaml_str += "  condition: " + sigma_rule["detection"]["condition"] + "\n"
    yaml_str += "falsepositives:\n"
    yaml_str += "  - Unknown\n"
    yaml_str += "level: " + sigma_rule["level"] + "\n"
    
    return yaml_str

def generate_yara_rule(iocs, rule_name, description):
    """Generate a YARA rule based on the provided IOCs"""
    # Create rule header
    safe_rule_name = re.sub(r'[^\w]', '_', rule_name)
    yara_rule = f'rule {safe_rule_name} {{\n'
    yara_rule += '    meta:\n'
    yara_rule += f'        description = "{description}"\n'
    yara_rule += f'        author = "{st.session_state.username}"\n'
    yara_rule += f'        date = "{datetime.now().strftime("%Y-%m-%d")}"\n'
    yara_rule += '        reference = "Generated by CyberShield Security Platform"\n'
    yara_rule += '    strings:\n'
    
    # Add IOC strings
    string_index = 1
    
    if iocs.get("domains"):
        for domain in iocs["domains"]:
            yara_rule += f'        $domain{string_index} = "{domain}" nocase\n'
            string_index += 1
    
    if iocs.get("ip_addresses"):
        for ip in iocs["ip_addresses"]:
            yara_rule += f'        $ip{string_index} = "{ip}"\n'
            string_index += 1
    
    if iocs.get("md5_hashes") or iocs.get("sha1_hashes") or iocs.get("sha256_hashes"):
        hash_index = 1
        
        for hash_list in [iocs.get("md5_hashes", []), iocs.get("sha1_hashes", []), iocs.get("sha256_hashes", [])]:
            for hash_value in hash_list:
                yara_rule += f'        $hash{hash_index} = "{hash_value}" nocase\n'
                hash_index += 1
    
    # Add condition
    yara_rule += '    condition:\n'
    
    if string_index > 1:
        yara_rule += f'        any of them\n'
    else:
        yara_rule += '        false // No indicators available for this rule\n'
    
    yara_rule += '}'
    
    return yara_rule

def generate_snort_rule(iocs, rule_name, description):
    """Generate a Snort rule based on the provided IOCs"""
    snort_rules = []
    
    # Generate alert rules for each IOC type
    if iocs.get("ip_addresses"):
        for ip in iocs["ip_addresses"]:
            rule = f'alert ip any any -> {ip} any (msg:"{rule_name} - Malicious IP"; '
            rule += f'flow:to_server; sid:{100000 + len(snort_rules)}; rev:1; '
            rule += f'reference:url,CyberShield; classtype:trojan-activity;)'
            snort_rules.append(rule)
    
    if iocs.get("domains"):
        for domain in iocs["domains"]:
            rule = f'alert tcp any any -> any 80 (msg:"{rule_name} - Malicious Domain"; '
            rule += f'flow:to_server,established; content:"Host:"; http_header; content:"{domain}"; '
            rule += f'nocase; sid:{100000 + len(snort_rules)}; rev:1; reference:url,CyberShield; '
            rule += f'classtype:trojan-activity;)'
            snort_rules.append(rule)
    
    if iocs.get("urls"):
        for url in iocs["urls"][:5]:  # Limit to 5 URLs to avoid excessive rules
            # Extract domain and path
            url_parts = url.replace("http://", "").replace("https://", "").split("/", 1)
            domain = url_parts[0]
            path = "/" + url_parts[1] if len(url_parts) > 1 else "/"
            
            rule = f'alert tcp any any -> any 80 (msg:"{rule_name} - Malicious URL"; '
            rule += f'flow:to_server,established; content:"Host: {domain}"; http_header; '
            rule += f'content:"{path}"; http_uri; nocase; sid:{100000 + len(snort_rules)}; '
            rule += f'rev:1; reference:url,CyberShield; classtype:trojan-activity;)'
            snort_rules.append(rule)
    
    # If no IOCs are available, add a comment
    if not snort_rules:
        snort_rules.append(f'# No indicators available for {rule_name}')
    
    # Add description comment
    snort_rules.insert(0, f'# {description}')
    snort_rules.insert(0, f'# Rule Name: {rule_name}')
    snort_rules.insert(0, f'# Generated by CyberShield Security Platform - {datetime.now().strftime("%Y-%m-%d")}')
    
    return "\n".join(snort_rules)

def create_download_link(file_content, file_name):
    """Create a download link for a file"""
    b64 = base64.b64encode(file_content.encode()).decode()
    href = f'<a href="data:file/txt;base64,{b64}" download="{file_name}">Download {file_name}</a>'
    return href

def show_rule_generation():
    """Display the security rule generation page"""
    st.title("⚙️ Security Rule Generation")
    
    st.markdown("""
    Automatically generate security detection rules based on threat intelligence indicators.
    These rules can be deployed to your security tools to detect malicious activity.
    """)
    
    # Input form for rule generation
    with st.form("rule_generation_form"):
        rule_name = st.text_input("Rule Name", "Malicious Activity Detection")
        description = st.text_area("Rule Description", "Detects indicators associated with malicious activity")
        
        # IOC inputs
        st.subheader("Indicators of Compromise (IOCs)")
        
        col1, col2 = st.columns(2)
        
        with col1:
            ip_addresses = st.text_area("IP Addresses (one per line)", 
                                       "192.168.1.100\n203.0.113.25")
            domains = st.text_area("Domains (one per line)", 
                                   "malicious-domain.com\nfakeupdates.net")
        
        with col2:
            urls = st.text_area("URLs (one per line)", 
                               "https://malicious-domain.com/download.php\nhttp://fakeupdates.net/update.exe")
            file_hashes = st.text_area("File Hashes (one per line)", 
                                      "d41d8cd98f00b204e9800998ecf8427e\ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")
        
        # Rule types to generate
        st.subheader("Rule Types")
        col1, col2, col3 = st.columns(3)
        
        with col1:
            generate_sigma = st.checkbox("Generate Sigma Rule", True)
        
        with col2:
            generate_yara = st.checkbox("Generate YARA Rule", True)
        
        with col3:
            generate_snort = st.checkbox("Generate Snort Rule", True)
        
        submit_button = st.form_submit_button("Generate Rules")
    
    # Process form submission
    if submit_button:
        # Parse and validate inputs
        parsed_ips = [ip.strip() for ip in ip_addresses.split("\n") if ip.strip()]
        parsed_domains = [domain.strip() for domain in domains.split("\n") if domain.strip()]
        parsed_urls = [url.strip() for url in urls.split("\n") if url.strip()]
        
        # Parse hashes and categorize by length
        md5_hashes = []
        sha1_hashes = []
        sha256_hashes = []
        
        for hash_value in [h.strip() for h in file_hashes.split("\n") if h.strip()]:
            if len(hash_value) == 32:  # MD5
                md5_hashes.append(hash_value)
            elif len(hash_value) == 40:  # SHA1
                sha1_hashes.append(hash_value)
            elif len(hash_value) == 64:  # SHA256
                sha256_hashes.append(hash_value)
        
        # Combine IOCs
        iocs = {
            "ip_addresses": parsed_ips,
            "domains": parsed_domains,
            "urls": parsed_urls,
            "md5_hashes": md5_hashes,
            "sha1_hashes": sha1_hashes,
            "sha256_hashes": sha256_hashes
        }
        
        # Check if at least one IOC is provided
        has_iocs = any(len(ioc_list) > 0 for ioc_list in iocs.values())
        
        if not has_iocs:
            st.error("Please provide at least one indicator of compromise")
        else:
            st.success("Rules generated successfully!")
            
            # Display tabs for each rule type
            rule_tabs = []
            
            if generate_sigma:
                rule_tabs.append("Sigma Rule")
            
            if generate_yara:
                rule_tabs.append("YARA Rule")
            
            if generate_snort:
                rule_tabs.append("Snort Rule")
            
            if rule_tabs:
                tabs = st.tabs(rule_tabs)
                
                tab_index = 0
                
                if generate_sigma:
                    with tabs[tab_index]:
                        sigma_rule = generate_sigma_rule(iocs, rule_name, description)
                        st.code(sigma_rule, language="yaml")
                        st.markdown(create_download_link(sigma_rule, f"{rule_name.replace(' ', '_')}.yml"), unsafe_allow_html=True)
                        tab_index += 1
                
                if generate_yara:
                    with tabs[tab_index]:
                        yara_rule = generate_yara_rule(iocs, rule_name, description)
                        st.code(yara_rule, language="c")
                        st.markdown(create_download_link(yara_rule, f"{rule_name.replace(' ', '_')}.yar"), unsafe_allow_html=True)
                        tab_index += 1
                
                if generate_snort:
                    with tabs[tab_index]:
                        snort_rule = generate_snort_rule(iocs, rule_name, description)
                        st.code(snort_rule, language="bash")
                        st.markdown(create_download_link(snort_rule, f"{rule_name.replace(' ', '_')}.rules"), unsafe_allow_html=True)
            
            # Display summary
            st.subheader("Rule Generation Summary")
            
            summary_data = {
                "Rule Type": [],
                "Status": [],
                "IOC Count": []
            }
            
            if generate_sigma:
                summary_data["Rule Type"].append("Sigma Rule")
                summary_data["Status"].append("Generated")
                summary_data["IOC Count"].append(len(parsed_ips) + len(parsed_domains) + len(parsed_urls))
            
            if generate_yara:
                summary_data["Rule Type"].append("YARA Rule")
                summary_data["Status"].append("Generated")
                summary_data["IOC Count"].append(len(parsed_domains) + len(parsed_ips) + len(md5_hashes) + len(sha1_hashes) + len(sha256_hashes))
            
            if generate_snort:
                summary_data["Rule Type"].append("Snort Rule")
                summary_data["Status"].append("Generated")
                summary_data["IOC Count"].append(len(parsed_ips) + len(parsed_domains) + len(parsed_urls))
            
            st.dataframe(pd.DataFrame(summary_data))
